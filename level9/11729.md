1. 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
2. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.

장대에 쌓인 원판의 개수 N 이면, 옮긴 횟수를 f(N)이라 하자.

핵심은 반경이 가장 긴 원판(n)을 3번 장대로 옮기면, 그 다음 필요한 이동 횟수는 f(N - 1)와 같다.

반경이 가장 긴 원판을 3번 장대로 옮기기 위해서는, 그 전까지의 원판들을 2번 장대에 완전히 옮겨야 하니까 f(N - 1), 그리고 가장 긴 원판을 3번으로 옮기는데 한번 필요하니

점화식을 세우면 `f(N) = 2f(N - 1) + 1`로 나타낼 수 있다.

그런데! 문제에서 수행 과정도 출력하라고 한다.

그럼 단순하게 위의 점화식으로 총 이동 횟수를 구하고 수행 과정은 

1. n - 1 개를 2번 장대로 옮김
2. n짜리를 3번으로 옮김 (1 3)
3. 2번 장대에 있는 걸 3번으로 옮김


```
def hanoi(n, a, b, c):
    if n == 1:
        print(a, b)
        return

    hanoi(n - 1, a, c, b)
    print(a, b)
    hanoi(n - 1, c, b, a)

def count(n):
    if n == 1:
        return 1
    return 2 * count(n - 1) + 1

n = int(input())
print(count(n))
hanoi(n, 1, 3, 2)
```
이렇게 풀이했다. 처음에는 `hanoi`함수에서 시작점, 도착점 두개만 넣으려고 했으나 이러면 $_3P_2$개 만큼의 경우의 수가 필요하다.(1 -> 2, 2 -> 3, 1 -> 3) 세개와 그 반대까지..

따라서 저 경우의 수를 3개까지 만들다가 위 코드의 규칙을 발견했다.

1 에서 3으로 옮기기 위해서는 n - 1 을 1에서 2로 옮기고, 젤 큰걸 1 에서 3으로 옮기고, 다시 n - 1 을 2 에서 3으로 옮기면 된다. 이걸 일반화하면 위의 코드가 된다. 이번엔 힌트도 아예 안보고 완전히 처음부터 진행하였는데 너무 깔끔하게 코드가 풀려서 기분이 좋다^^
